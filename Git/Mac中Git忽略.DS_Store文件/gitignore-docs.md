# docs/.gitignore


> https://git-scm.com/docs/gitignore



Note: 文档中英文段落的下一段落为当前段落的中文翻译，使用 "沉浸式翻译" 插件，翻译服务为谷歌翻译。

## NAME

gitignore - Specifies intentionally untracked files to ignore
gitignore - 指定要忽略的有意未跟踪的文件

## SYNOPSIS

$XDG_CONFIG_HOME/git/ignore, $GIT_DIR/info/exclude, .gitignore

## DESCRIPTION

A `gitignore` file specifies intentionally untracked files that Git should ignore. Files already tracked by Git are not affected; see the NOTES below for details.
`gitignore` 文件指定 Git 应该忽略的有意未跟踪的文件。 Git 已经跟踪的文件不受影响；有关详细信息，请参阅下面的注释。

Each line in a `gitignore` file specifies a pattern. When deciding whether to ignore a path, Git normally checks `gitignore` patterns from multiple sources, with the following order of precedence, from highest to lowest (within one level of precedence, the last matching pattern decides the outcome):
`gitignore` 文件中的每一行指定一个模式。在决定是否忽略路径时，Git 通常会检查来自多个来源的 `gitignore` 模式，按照以下优先级从高到低的顺序（在一个优先级内，最后匹配的模式决定结果）：

- Patterns read from the command line for those commands that support them.
    从支持它们的命令的命令行读取模式。
- Patterns read from a `.gitignore` file in the same directory as the path, or in any parent directory (up to the top-level of the working tree), with patterns in the higher level files being overridden by those in lower level files down to the directory containing the file. These patterns match relative to the location of the `.gitignore` file. A project normally includes such `.gitignore` files in its repository, containing patterns for files generated as part of the project build.
    从与路径相同的目录或任何父目录（直到工作树的顶层）中的 `.gitignore` 文件读取模式，较高级别文件中的模式被较低级别文件中的模式覆盖到包含该文件的目录。这些模式相对于 `.gitignore` 文件的位置进行匹配。项目通常在其存储库中包含此类 `.gitignore` 文件，其中包含作为项目构建的一部分生成的文件的模式。
- Patterns read from `$GIT_DIR/info/exclude`.
    从 `$GIT_DIR/info/exclude` 读取的模式。
- Patterns read from the file specified by the configuration variable `core.excludesFile`.
    从配置变量 `core.excludesFile` 指定的文件中读取的模式。

Which file to place a pattern in depends on how the pattern is meant to be used.
放置模式的文件取决于模式的用途。

- Patterns which should be version-controlled and distributed to other repositories via clone (i.e., files that all developers will want to ignore) should go into a `.gitignore` file.
    应该进行版本控制并通过克隆分发到其他存储库的模式（即所有开发人员都希望忽略的文件）应该放入 `.gitignore` 文件中。
- Patterns which are specific to a particular repository but which do not need to be shared with other related repositories (e.g., auxiliary files that live inside the repository but are specific to one user’s workflow) should go into the `$GIT_DIR/info/exclude` file.
    特定于特定存储库但不需要与其他相关存储库共享的模式（例如，位于存储库内但特定于一个用户的工作流的辅助文件）应该放入 `$GIT_DIR/info/exclude` 文件中。
- Patterns which a user wants Git to ignore in all situations (e.g., backup or temporary files generated by the user’s editor of choice) generally go into a file specified by `core.excludesFile` in the user’s `~/.gitconfig`. Its default value is $XDG_CONFIG_HOME/git/ignore. If $XDG_CONFIG_HOME is either not set or empty, $HOME/.config/git/ignore is used instead.
    用户希望 Git 在所有情况下都忽略的模式（例如，由用户选择的编辑器生成的备份或临时文件）通常会进入用户的`~/.gitconfig` 中的 `core.excludesFile` 指定的文件。它的默认值是 $XDG_CONFIG_HOME/git/ignore。如果 $XDG_CONFIG_HOME 未设置或为空，则使用 $HOME/.config/git/ignore 代替。

The underlying Git plumbing tools, such as *git ls-files* and *git read-tree*, read `gitignore` patterns specified by command-line options, or from files specified by command-line options. Higher-level Git tools, such as *git status* and *git add*, use patterns from the sources specified above.
底层 Git 管道工具，例如 git ls-files 和 git read-tree，读取命令行选项指定的 `gitignore` 模式，或从命令行选项指定的文件中读取。更高级别的 Git 工具，例如 git status 和 git add，使用来自上面指定来源的模式。

## PATTERN FORMAT

- A blank line matches no files, so it can serve as a separator for readability.
    空行不匹配任何文件，因此它可以作为可读性的分隔符。
- A line starting with # serves as a comment. Put a backslash ("`\`") in front of the first hash for patterns that begin with a hash.
    以# 开头的行用作注释。对于以散列开头的模式，在第一个散列前面放置一个反斜杠（“ `\` ”）。
- Trailing spaces are ignored unless they are quoted with backslash ("`\`").
    尾随空格将被忽略，除非它们用反斜杠（“ `\` ”）引用。
- An optional prefix "`!`" which negates the pattern; any matching file excluded by a previous pattern will become included again. It is not possible to re-include a file if a parent directory of that file is excluded. Git doesn’t list excluded directories for performance reasons, so any patterns on contained files have no effect, no matter where they are defined. Put a backslash ("`\`") in front of the first "`!`" for patterns that begin with a literal "`!`", for example, "`\!important!.txt`".
    一个可选的前缀“ `!` ”，它否定了模式；先前模式排除的任何匹配文件将再次包含在内。如果排除了该文件的父目录，则无法重新包含该文件。出于性能原因，Git 不会列出排除的目录，因此包含文件的任何模式都无效，无论它们在何处定义。对于以文字“ `!` ”开头的模式，例如“ `\!important!.txt` ”，在第一个“ `!` ”前面放置一个反斜杠（“ `\` ”）。
- The slash */* is used as the directory separator. Separators may occur at the beginning, middle or end of the `.gitignore` search pattern.
    斜杠 / 用作目录分隔符。分隔符可能出现在 `.gitignore` 搜索模式的开头、中间或结尾。
- If there is a separator at the beginning or middle (or both) of the pattern, then the pattern is relative to the directory level of the particular `.gitignore` file itself. Otherwise the pattern may also match at any level below the `.gitignore` level.
    如果模式的开头或中间（或两者）有一个分隔符，那么该模式是相对于特定 `.gitignore` 文件本身的目录级别的。否则，该模式也可以匹配 `.gitignore` 级别以下的任何级别。
- If there is a separator at the end of the pattern then the pattern will only match directories, otherwise the pattern can match both files and directories.
    如果模式末尾有分隔符，那么模式将只匹配目录，否则模式可以匹配文件和目录。
- For example, a pattern `doc/frotz/` matches `doc/frotz` directory, but not `a/doc/frotz` directory; however `frotz/` matches `frotz` and `a/frotz` that is a directory (all paths are relative from the `.gitignore` file).
    例如，模式 `doc/frotz/` 匹配 `doc/frotz` 目录，但不匹配 `a/doc/frotz` 目录；但是 `frotz/` 匹配 `frotz` 和 `a/frotz` 是一个目录（所有路径都是 `.gitignore` 文件的相对路径）。
- An asterisk "`*`" matches anything except a slash. The character "`?`" matches any one character except "`/`". The range notation, e.g. `[a-zA-Z]`, can be used to match one of the characters in a range. See fnmatch(3) and the FNM_PATHNAME flag for a more detailed description.
    星号“ `*` ”匹配除斜杠以外的任何内容。字符“ `?` ”匹配除“ `/` ”之外的任意一个字符。范围符号，例如 `[a-zA-Z]` ，可用于匹配范围内的字符之一。有关更详细的说明，请参阅 fnmatch(3) 和 FNM_PATHNAME 标志。

Two consecutive asterisks ("`**`") in patterns matched against full pathname may have special meaning:
与完整路径名匹配的模式中的两个连续星号（“ `**` ”）可能具有特殊含义：

- A leading "`**`" followed by a slash means match in all directories. For example, "`**/foo`" matches file or directory "`foo`" anywhere, the same as pattern "`foo`". "`**/foo/bar`" matches file or directory "`bar`" anywhere that is directly under directory "`foo`".
    前导“ `**` ”后跟斜线表示匹配所有目录。例如，“ `**/foo` ”在任何地方匹配文件或目录“ `foo` ”，与模式“ `foo` ”相同。 “ `**/foo/bar` ”与目录“ `foo` ”正下方的任何位置的文件或目录“ `bar` ”匹配。
- A trailing "`/**`" matches everything inside. For example, "`abc/**`" matches all files inside directory "`abc`", relative to the location of the `.gitignore` file, with infinite depth.
    尾随的“ `/**` ”匹配里面的所有内容。例如，“ `abc/**` ”匹配目录“ `abc` ”内的所有文件，相对于 `.gitignore` 文件的位置，具有无限深度。
- A slash followed by two consecutive asterisks then a slash matches zero or more directories. For example, "`a/**/b`" matches "`a/b`", "`a/x/b`", "`a/x/y/b`" and so on.
    一个斜杠后跟两个连续的星号，然后一个斜杠匹配零个或多个目录。例如，“ `a/**/b` ”匹配“ `a/b` ”、“ `a/x/b` ”、“ `a/x/y/b` ”等。
- Other consecutive asterisks are considered regular asterisks and will match according to the previous rules.
    其他连续的星号被认为是常规星号，将按照前面的规则进行匹配。

## CONFIGURATION

The optional configuration variable `core.excludesFile` indicates a path to a file containing patterns of file names to exclude, similar to `$GIT_DIR/info/exclude`. Patterns in the exclude file are used in addition to those in `$GIT_DIR/info/exclude`.
可选的配置变量 `core.excludesFile` 指示包含要排除的文件名模式的文件的路径，类似于 `$GIT_DIR/info/exclude` 。除 `$GIT_DIR/info/exclude` 中的模式外，还使用排除文件中的模式。

## NOTES

The purpose of gitignore files is to ensure that certain files not tracked by Git remain untracked.
gitignore 文件的目的是确保 Git 未跟踪的某些文件保持未跟踪状态。

To stop tracking a file that is currently tracked, use *git rm --cached*.
要停止跟踪当前跟踪的文件，请使用 git rm --cached。

Git does not follow symbolic links when accessing a `.gitignore` file in the working tree. This keeps behavior consistent when the file is accessed from the index or a tree versus from the filesystem.
在访问工作树中的 `.gitignore` 文件时，Git 不遵循符号链接。当从索引或树访问文件与从文件系统访问文件时，这可以保持行为一致。

## EXAMPLES

- The pattern `hello.*` matches any file or directory whose name begins with `hello.`. If one wants to restrict this only to the directory and not in its subdirectories, one can prepend the pattern with a slash, i.e. `/hello.*`; the pattern now matches `hello.txt`, `hello.c` but not `a/hello.java`.
    模式 `hello.*` 匹配名称以 `hello.` 开头的任何文件或目录。如果只想将其限制在目录而不是其子目录中，则可以在模式前加上斜杠，即 `/hello.*` ；该模式现在匹配 `hello.txt` 、 `hello.c` 但不匹配 `a/hello.java` 。
- The pattern `foo/` will match a directory `foo` and paths underneath it, but will not match a regular file or a symbolic link `foo` (this is consistent with the way how pathspec works in general in Git)
    模式 `foo/` 将匹配目录 `foo` 及其下的路径，但不会匹配常规文件或符号链接 `foo` （这与 pathspec 在 Git 中的一般工作方式一致）
- The pattern `doc/frotz` and `/doc/frotz` have the same effect in any `.gitignore` file. In other words, a leading slash is not relevant if there is already a middle slash in the pattern.
    模式 `doc/frotz` 和 `/doc/frotz` 在任何 `.gitignore` 文件中具有相同的效果。换句话说，如果模式中已经有中间斜杠，则前导斜杠不相关。
- The pattern "foo/*", matches "foo/test.json" (a regular file), "foo/bar" (a directory), but it does not match "foo/bar/hello.c" (a regular file), as the asterisk in the pattern does not match "bar/hello.c" which has a slash in it.
    模式“foo/*”匹配“foo/test.json”（常规文件）、“foo/bar”（目录），但不匹配“foo/bar/hello.c”（常规文件） )，因为模式中的星号与其中有斜杠的“bar/hello.c”不匹配。

```
    $ git status
    [...]
    # Untracked files:
    [...]
    #       Documentation/foo.html
    #       Documentation/gitignore.html
    #       file.o
    #       lib.a
    #       src/internal.o
    [...]
    $ cat .git/info/exclude
    # ignore objects and archives, anywhere in the tree.
    *.[oa]
    $ cat Documentation/.gitignore
    # ignore generated html files,
    *.html
    # except foo.html which is maintained by hand
    !foo.html
    $ git status
    [...]
    # Untracked files:
    [...]
    #       Documentation/foo.html
    [...]
```

Another example:

```
    $ cat .gitignore
    vmlinux*
    $ ls arch/foo/kernel/vm*
    arch/foo/kernel/vmlinux.lds.S
    $ echo '!/vmlinux*' >arch/foo/kernel/.gitignore
```

The second .gitignore prevents Git from ignoring `arch/foo/kernel/vmlinux.lds.S`.
第二个 .gitignore 防止 Git 忽略 `arch/foo/kernel/vmlinux.lds.S` 。

Example to exclude everything except a specific directory `foo/bar` (note the `/*` - without the slash, the wildcard would also exclude everything within `foo/bar`):
排除除特定目录 `foo/bar` 之外的所有内容的示例（注意 `/*` - 没有斜杠，通配符也会排除 `foo/bar` 中的所有内容）：

```
    $ cat .gitignore
    # exclude everything except directory foo/bar
    /*
    !/foo
    /foo/*
    !/foo/bar
```

## SEE ALSO

[git-rm[1\]](https://git-scm.com/docs/git-rm), [gitrepository-layout[5\]](https://git-scm.com/docs/gitrepository-layout), [git-check-ignore[1\]](https://git-scm.com/docs/git-check-ignore)
git-rm[1] , gitrepository-layout[5] , git-check-ignore[1]

## GIT

Part of the [git[1\]](https://git-scm.com/docs/git) suite
git[1] 套件的一部分
