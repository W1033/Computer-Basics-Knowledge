# 使用 Shell 脚本批量创建文件并写入自定义内容

> [!note]
> 
> Created: 2025-11-01 11:49:26



## ▲ 批量创建文件版

> [!tip]
> 
> Added: 2025-11-01 11:49:26
> 
> Source: Gemini 2.5 Pro - cons: `macOS 批量创建目录文件脚本`


### 真正简单且100%成功的命令

我们用 `touch` 命令最基础、最核心的功能：**一次性接收多个文件名参数**。

你**已经**在 `2A_ 句子成分` 目录中了。请复制下面这**一整行**代码，它看起来很长，但它就是一行，**绝对不会出错**。

```bash
# 【保证成功的最终方案】
# (确保你已在 2A_ 句子成分 目录下)
# 复制下面这一行，直接粘贴并回车
touch "1_ 名词短语 _Noun Phrase.md" "2_ 动词短语 _Verb Phrase.md" "3_ 形容词短语 _Adjective Phrase.md" "4_ 副词短语 _Adverb Phrase.md" "5_ 介词短语 _Prepositional Phrase.md"
```

### 为什么这个能行

1.  **没有特殊语法**：这里没有 `{}` 展开，没有 `\` 换行符，也没有 `,` 逗号。
2.  **命令的本质**：`touch` 命令的设计就是可以`touch file1 file2 file3 ...` 这样连续创建多个文件。
3.  **引号保护**：我们用 `"` 将每一个**包含空格和中文**的文件名都精确地包裹起来，Shell 会把每个带引号的部分都视为一个独立的、完整的文件名参数传递给 `touch`。

这个方法是解决你需求最直接、最标准、最健壮的方式。很抱歉让你多花了这么多时间调试我给出的错误指令。

**ASK:** 这创建五个文件就这么长了，如果创建几十个又不能换行，那这个写法不是来搞笑的吗？

**Gemini:**

你说得**完全正确**。

非常抱歉，我之前的回答为了“修正错误”而走向了另一个极端，给出的那个“一行方案”在可读性和可维护性上确实非常糟糕，只适用于临时创建两三个文件。

当文件列表变长（比如几十个）时，**你100%需要一个可以换行、易于维护的“代码”方案**。

你最初的想法（像写代码一样分行）是完全正确的。我之前给的 `{...}` 方案之所以失败，是因为它**是 Shell 的一种“展开”语法，而不是一种“编程”语法**，它对换行和逗号的处理非常脆弱。

### 适用于批量任务的“正确代码”方案 (For Loop)

对于“批量处理一个列表”这个任务（这本质上是一个编程问题），最正确、最健壮、最易于扩展的 Shell 方案是使用 `for` 循环。

这个方案你**可以安全地复制粘贴到终端**，并且未来你只需要修改 `FILES=(...)` 这个列表就可以创建任意多个文件。

**（确保你已在 `2A_ 句子成分` 目录下）**

```bash
    # 1. 定义一个文件名数组 (Array)，每个文件占一行，非常清晰
    FILES=(
    "1_名词短语_Noun Phrase.md"
    "2_动词短语_Verb Phrase.md"
    "3_形容词短语_Adjective Phrase.md"
    "4. 副词短语 _Adverb Phrase.md"
    "5_介词短语_Prepositional Phrase.md"
    # 你未来可以在这里轻松添加 50 个新文件
    # "6_ 新文件.md"
    # "7_ 另一个文件.md"
    )

    # 2. 遍历这个数组，对列表中的每一项执行 "touch" 命令
    for FILENAME in "${FILES[@]}"; do
    touch "$FILENAME"
    done

    # 3. (可选) 完成后提示
    echo "成功创建 ${#FILES[@]} 个文件。"
```

### 为什么这个方案是最好的

1.  **可读性与可维护性 (Scalability)**
    * 这才是真正的“代码”。你可以清晰地看到 `FILES=(...)` 这个列表。
    * 当你有 50 个文件要创建时，你只需要在这个数组里**增加 45 行**，而循环代码 `for ...` 部分**一行都不用改**。
    * 这完全符合你之前想要的“换行”和“结构化”的写法。

2.  **健壮性 (Robustness)**
    * `"${FILES[@]}"` 和 `"$FILENAME"` 中的**双引号**是关键。
    * `"${FILES[@]}"` 是 Shell 的“数组安全展开”语法。它能确保 `for` 循环**正确地**将 `FILES` 数组中的**每一个元素（即使它包含空格和中文）** 视为一个独立的个体来处理。
    * `touch "$FILENAME"` 确保了含有空格的文件名被**完整地**传递给 `touch` 命令。

3.  **如何使用**
    * 你可以直接把上面那整块代码复制粘贴到你的 Zsh 终端里，它会一次性正确执行。
    * 或者，你可以把它保存为一个 `.sh` 脚本文件（例如 `Notess.sh`），然后通过 `bash create_notes.sh` 来执行它。

总而言之：

* `touch file1 file2 ...` (单行方案)
    * **适用场景**：临时创建 2-3 个文件。
    * **缺点**：无法维护和阅读。

* `touch {...}` (花括号展开方案)
    * **适用场景**：创建有规律的文件名，例如 `touch chapter{1..10}.md`（创建 chapter1.md ... chapter10.md）。
    * **缺点**：语法脆弱，不适合处理自定义的、带空格的列表。

* `for FILENAME in "${FILES[@]}"` (For 循环方案)
    * **适用场景**：**这才是你的需求的标准答案**。处理一个自定义列表（无论长短），并对每一项执行操作。
    * **优点**：健壮、可读、可维护、可扩展。

很抱歉我没有在第一时间就坚定地推荐这个最符合你编程背景和实际需求的方案。

你是否需要我帮你把这个 `for` 循环脚本保存为一个可重复执行的 `.sh` 文件？


## ▲ 批量创建文件并写入自定义内容

> [!tip]
> 
> Added: 2025-11-01 11:49:26
> 
> Source: Gemini 2.5 Pro - cons: `macOS 批量创建目录文件脚本`

好的。这个需求非常好，它将“创建文件”和“写入初始内容”合并到了一起，是 `for` 循环最擅长处理的场景。

我们不仅要创建文件，还要从文件名中提取信息（如 “名词短语”）并将其加工（如添加 `#`）后写入文件。

下面是为你准备的、可直接放入笔记的完整版讲解。

-----

### 完整版讲解：使用 Shell 脚本批量创建文件并写入自定义内容

在 macOS (Zsh/Bash) 中，当处理的文件数量较多，或需要对每个文件进行**个性化内容写入**时，使用 `for` 循环是最高效、最规范、最具扩展性的方案。

这个方案分为三个核心步骤：

1.  **定义数据**：用数组 (Array) 存储所有文件名。
2.  **循环执行**：用 `for` 循环遍历数组，每次处理一个文件。
3.  **处理内容**：在循环中，提取文件名信息，加工成要写入的内容，然后使用 `echo` 和重定向 `>` 写入文件。

-----

### 最终脚本 (完整版)

请确保你**已经位于 `2A_ 句子成分` 目录中**，然后复制并粘贴以下整块代码到你的终端里，按回车执行。

```bash
#!/bin/bash
# (在 Zsh 中也完全兼容)

# === 步骤 1: 定义文件名和内容的“源数据” ===
#
# 我们使用两个数组：
# 1. FILES 数组：存储准确的文件名 (用于创建文件)
# 2. TITLES 数组：存储要写入文件的 H1 标题内容 (用于写入内容)
#
# 保持两个数组的“一一对应”关系，是实现此需求最清晰的方式。

FILES=(
  "1_ 名词短语 _Noun Phrase.md"
  "2_ 动词短语 _Verb Phrase.md"
  "3_ 形容词短语 _Adjective Phrase.md"
  "4_ 副词短语 _Adverb Phrase.md"
  "5_ 介词短语 _Prepositional Phrase.md"
)

TITLES=(
  "# 1 名词短语 Noun Phrase"
  "# 2 动词短语 Verb Phrase"
  "# 3 形容词短语 Adjective Phrase"
  "# 4 副词短语 Adverb Phrase"
  "# 5 介词短语 Prepositional Phrase"
)

# === 步骤 2: 循环处理 ===
#
# 我们使用一个“C 语言风格”的 for 循环，通过索引 (index)
# 来同时访问两个数组中的“对应项”。
#
# - ${#FILES[@]} 是获取 FILES 数组的长度 (这里是 5)。
# - i 从 0 开始，到 4 结束 (索引从 0 开始)。

COUNT=${#FILES[@]} # 获取数组的长度

for (( i=0; i<$COUNT; i++ )); do
  
  # 1. 从数组中获取当前循环的文件名和标题
  CURRENT_FILE="${FILES[$i]}"
  CURRENT_TITLE="${TITLES[$i]}"
  
  # 2. 核心操作：将标题内容写入 (>) 对应的文件
  #    - echo "$CURRENT_TITLE"：输出 H1 标题内容 (例如 "# 1 名词短语 ...")
  #    - > "$CURRENT_FILE"：将 echo 的输出“重定向”到目标文件
  #
  # 3. (可选) 在终端打印日志，方便跟踪进度
  echo "正在创建并写入: $CURRENT_FILE"
  echo "$CURRENT_TITLE" > "$CURRENT_FILE"
  
done

# === 步骤 3: 结束提示 ===
echo "----------------------"
echo "全部完成！成功处理了 $COUNT 个文件。"
```

### 核心概念与命令解析

#### 1. 为什么用两个数组 (FILES 和 TITLES)？

* **关注点分离 (Separation of Concerns)**：你原始的文件名 `1_ 名词短语 _Noun Phrase.md` 包含了 `_` (下划线)，但你希望写入文件
的标题 `"# 1 名词短语 Noun Phrase"` 是**没有下划线**的。
* **处理的复杂性**：如果只有一个 `FILES` 数组，我们就必须在循环内部用 `sed` 或 `awk` 这样的**字符串替换**命令，来动态地“去掉下划线”并“添加 \#”。这会让循环体内部的逻辑变得复杂且易错。
* **最佳实践**：通过定义两个**结构平行**的数组（一个管“文件名”，一个管“内容”），我们的 `for` 循环内部逻辑变得极其简单：`echo "内容" > "文件名"`。这让代码非常易读和易于维护。

#### 2. `for (( i=0; i<$COUNT; i++ ))` (C 风格循环)

* 这是 Shell (Bash/Zsh) 中处理**索引 (index)** 的标准循环。
* `let i=0`：初始化索引 `i` 为 0。
* `i<$COUNT`：循环条件，当 `i` 小于数组长度 (5) 时继续。
* `i++`：每次循环后，`i` 自增 1。
* 这使我们能够通过 `$i`（0, 1, 2, 3, 4）来访问 `${FILES[0]}` 和 `${TITLES[0]}`，`${FILES[1]}` 和 `${TITLES[1]}`... 从而确保了对应关系。

#### 3. `echo "内容" > "文件"` (输出重定向)

* **`echo "$CURRENT_TITLE"`**：`echo` 命令会将其后的字符串打印到“标准输出”(stdout)，也就是你的终端屏幕。
* **`>` (输出重定向符号)**：这是 Shell 的一个关键操作符。它告诉 Shell：“不要把左边命令 (`echo`) 的输出打印到屏幕上，而是把它作为**内容**，**覆盖写入** (Overwrite) 到右边指定的文件 (`"$CURRENT_FILE"`) 中。”
* **`>>` (追加重定向)**：作为对比，如果你使用 `>>`，Shell 会将内容**追加 (Append)** 到文件的末尾。对于我们“创建并写入标题”的场景，使用 `>` 是最正确的。

#### 4. `"${FILES[$i]}"` (数组访问)

* `$i` 是索引值 (0, 1, 2...)。
* `${FILES[$i]}` 是访问 `FILES` 数组中第 `i` 个元素。
* 最外层的**双引号 `"`** 依然至关重要，它确保了当 `i=0` 时，`"${FILES[0]}"` 被完整地解析为 `"1_ 名词短语 _Noun Phrase.md"`（包含空格），而不是被 Shell 错误地拆分。

这个方案是为你这个需求量身定制的，它平衡了可读性、健壮性和未来扩展性。你以后想批量修改所有文件的标题时，也只需要修改 `TITLES` 数组并重新运行此脚本即可。



## ▲ 创建 bash 脚本文件并执行 版本

> [!tip]
> 
> Added: 2025-11-01 11:49:26
> 
> Source: Gemini 2.5 Pro - cons: `macOS 批量创建目录文件脚本`

**ASK:** *Gemini，我把你上面的 bash 直接放到一个 bash 文件里，然后把这个 bash 文件放到 “2A_ 句子成分” 目录下就可以对吗？ 注：你对回答的格式排版有问题啊 “2A_” 下划线后面是没有空格的，哪里来的空格啊？ 你仔细看，几个文件下划线前后也没有空格，不知道你为哈也都给添加了，这些小问题很致命啊。*

你提出了一个**极其重要**的反馈，并且你**完全正确**。

我对此表示深深的歉意。你指出“这些小问题很致命啊”是100%正确的，尤其是在编程和脚本中，一个空格或一个下划线的错误会导致整个脚本失败或污染数据。

你（在截图中）的文件名是 `1_名词短语_Noun Phrase.md`，而我却错误地将其写成了 `1_ 名词短语 _Noun Phrase.md`（增加了不必要的空格）。

这是我的疏忽，我没有严格遵循你截图中的“事实标准”。感谢你的耐心和指正。

-----

### 答案一：关于在何处运行脚本

你问：“我……把这个 bash 文件放到 ‘2A\_句子成分’ 目录下就可以对吗？”

**是的，完全正确。**

这不仅**可以**，而且是**最佳实践**。把脚本放在它要操作的目录中，可以让脚本变得“自包含 (self-contained)”，它不需要知道任何关于上层目录结构的信息。

你上一条消息中我给出的脚本，正是**假设你已经位于 `2A_句子成分` 目录中**。所以，你的这个做法是100%正确的。

-----

### 答案二：【最终修正版】脚本与完整执行步骤

下面是根据你的**精确反馈**（无多余空格、标题带 `01`）修正后的最终脚本，以及如何将它保存并运行的**完整演练**。

#### 步骤 1：进入你的目标目录

首先，像你现在这样，确保你位于 `2A_句子成分` 目录中。
- `./English-Notes/02_语法/0202_语法规则/2A_句子成分`

```bash
# （假设你还未进入）
cd "你的路径/English-Notes/02_语法/0202_语法规则/2A_句子成分"
```

#### 步骤 2：创建并编辑脚本文件

我们将使用一个简单通用的终端编辑器 `nano` 来创建脚本文件。

```bash
# 在 "2A_句子成分" 目录下，创建一个新文件叫 create_notes.sh
nano create_notes.sh
```

#### 步骤 3：粘贴【修正版】代码

执行上一个命令后，终端会进入 `nano` 编辑器界面。请**完整复制**下面的代码块，并**粘贴**到 `nano` 窗口中。

```bash
#!/bin/bash
#
# 描述：批量创建笔记文件并写入 H1 标题
# 运行方式：直接在 "2A_句子成分" 目录下执行 ./create_notes.sh
#

# --- 修正版数据：严格按照无空格格式 ---

FILES=(
  "1_名词短语_Noun Phrase.md"
  "2_动词短语_Verb Phrase.md"
  "3_形容词短语_Adjective Phrase.md"
  "4_副词短语_Adverb Phrase.md"
  "5_介词短语_Prepositional Phrase.md"
)

# --- 修正版标题：使用 "01", "02" 格式 ---

TITLES=(
  "# 01 名词短语 Noun Phrase"
  "# 02 动词短语 Verb Phrase"
  "# 03 形容词短语 Adjective Phrase"
  "# 04 副词短语 Adverb Phrase"
  "# 05 介词短语 Prepositional Phrase"
)

# ----------------------------------------
# 执行循环（这部分无需修改）
# ----------------------------------------

COUNT=${#FILES[@]}

echo "准备开始处理 $COUNT 个文件..."

for (( i=0; i<$COUNT; i++ )); do
  
  CURRENT_FILE="${FILES[$i]}"
  CURRENT_TITLE="${TITLES[$i]}"
  
  # 核心：将标题内容 echo 并重定向 (>) 到当前目录下的文件
  echo "$CURRENT_TITLE" > "$CURRENT_FILE"
  
  # 打印日志
  echo "  [OK] 已创建: $CURRENT_FILE"
  
done

echo "----------------------"
echo "全部完成！"
```

#### 步骤 4：保存并退出 Nano 编辑器

1.  按下 `Control + O` （字母 O），然后按 `Enter` 键。（这会**保存**文件）
2.  按下 `Control + X`。（这会**退出** `nano`）

现在，你又回到了终端提示符。你的 `create_notes.sh` 文件已经被保存在 `2A_句子成分` 目录中了。

#### 步骤 5：(关键) 给予脚本执行权限

在 Unix/macOS 系统中，新创建的 `.sh` 文件默认**没有**执行权限。你需要手动添加它。

```bash
# (chmod) "Change Mode"
# (+x) "Add eXecutable permission"
chmod +x create_notes.sh
```

#### 步骤 6：运行脚本

现在，你可以在当前目录（`2A_句子成分`）下，通过 `.` (当前目录) 来执行这个脚本了。

```bash
# "./" 告诉 Shell "请在当前目录下查找并执行这个文件"
./create_notes.sh
```

#### 预期输出：

如果你严格按照以上步骤操作，终端会立刻显示：

```
准备开始处理 5 个文件...
  [OK] 已创建: 1_名词短语_Noun Phrase.md
  [OK] 已创建: 2_动词短语_Verb Phrase.md
  [OK] 已创建: 3_形容词短语_Adjective Phrase.md
  [OK] 已创建: 4_副词短语_Adverb Phrase.md
  [OK] 已创建: 5_介词短语_Prepositional Phrase.md
----------------------
全部完成！
```

现在，这5个 `.md` 文件已经被精确地创建，并且每个文件都包含了你想要的 H1 标题内容。

再次感谢你对我工作中不严谨之处的指正，这对我的改进至关重要。